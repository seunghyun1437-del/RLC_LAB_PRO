<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RLC Lab Pro</title>
  <style>
:root {
  --bg: #0f1115;
  --card: #161a22;
  --text: #e7eaf0;
  --muted: #9aa4b2;
  --primary: #5eb1ff;
  --danger: #ff6b6b;
  --border: #232838;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
  color: var(--text);
  background: radial-gradient(1200px 800px at 10% -10%, #1a2130 0%, var(--bg) 40%);
}

.container { max-width: 1100px; margin: 0 auto; padding: 16px; }
header h1 { margin: 8px 0 0; font-size: 24px; letter-spacing: 0.5px; }

.grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 16px;
}

.card {
  grid-column: span 12;
  background: linear-gradient(180deg, #171c27 0%, #121722 100%);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 16px;
  box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 10px 30px rgba(0,0,0,0.25);
}

#card-params { grid-column: span 4; }
#card-results { grid-column: span 4; }
#card-plot { grid-column: span 12; }

@media (max-width: 980px) {
  #card-params, #card-results { grid-column: span 12; }
}

.form-row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
label { font-size: 12px; color: var(--muted); }
input[type="number"] {
  background: #0f1420;
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  padding: 10px 12px;
  outline: none;
}
input[type="number"]:focus { border-color: #4868ff; box-shadow: 0 0 0 3px rgba(72,104,255,0.18); }

.buttons { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
.buttons.small { margin-top: 4px; }
button {
  appearance: none;
  border: 1px solid #3153cc;
  background: linear-gradient(180deg, #3a5eea 0%, #2b49b8 100%);
  color: white;
  border-radius: 8px;
  padding: 10px 14px;
  cursor: pointer;
}
button:hover { filter: brightness(1.05); }
button.ghost {
  background: transparent;
  border-color: var(--border);
  color: var(--muted);
}
button.active { box-shadow: 0 0 0 2px rgba(94,177,255,0.35) inset; }

.error { color: var(--danger); min-height: 1.2em; margin-top: 6px; }
.hint { color: var(--muted); margin-top: 8px; font-size: 13px; }
.hint .qnote { margin-top: 6px; }
.hint .qtitle { color: var(--text); font-weight: 600; margin-bottom: 6px; }
.hint .qcols { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px 16px; }
.hint .qsub { color: var(--primary); font-weight: 600; margin-bottom: 4px; }
.hint ul { margin: 0; padding-left: 16px; }
.hint li { margin: 2px 0; }
@media (max-width: 640px) {
  .hint .qcols { grid-template-columns: 1fr; }
}

.results { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px 12px; }
.results .k { color: var(--primary); }

.foot { color: var(--muted); font-size: 12px; text-align: center; padding-bottom: 24px; }

canvas { width: 100%; }
#card-plot canvas { height: 240px; }
@media (min-width: 980px) {
  #card-plot canvas { height: 260px; }
}

.badge {
  display: inline-block;
  margin-top: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  border: 1px solid var(--border);
  color: var(--text);
}
.badge.overdamped { background: #3a3f4e; }
.badge.broad { background: rgba(94,177,255,0.12); border-color: #3b4f70; }
.badge.moderate { background: rgba(255,198,94,0.12); border-color: #6a5630; }
.badge.sharp { background: rgba(255,107,107,0.12); border-color: #6a3030; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header class="container">
    <h1>RLC Lab Pro</h1>
  </header>

  <main class="container grid">
    <section class="card" id="card-params">
      <h2>ÌååÎùºÎØ∏ÌÑ∞</h2>
      <div class="form-row">
        <label for="rInput">R (Œ©)</label>
        <input id="rInput" type="number" inputmode="decimal" step="any" placeholder="Ïòà: 100" />
      </div>
      <div class="form-row">
        <label for="lInput">L (H)</label>
        <input id="lInput" type="number" inputmode="decimal" step="any" placeholder="Ïòà: 0.01" />
      </div>
      <div class="form-row">
        <label for="cInput">C (F)</label>
        <input id="cInput" type="number" inputmode="decimal" step="any" placeholder="Ïòà: 0.000001" />
      </div>
      <div class="form-row">
        <label for="fInput">f (Hz)</label>
        <input id="fInput" type="number" inputmode="decimal" step="any" placeholder="Ïòà: 1000" />
      </div>
      <div class="form-row">
        <label for="vinInput">Vin [V]</label>
        <input id="vinInput" type="number" inputmode="decimal" step="any" placeholder="Ïòà: 1.0" />
      </div>
      <div class="buttons">
        <button id="btnCalc">Í≥ÑÏÇ∞ÌïòÍ∏∞</button>
        <button id="btnReset" class="ghost">Î¶¨ÏÖã</button>
      </div>
      <p id="inlineError" class="error" aria-live="polite"></p>
    </section>

    <section class="card" id="card-results">
      <h2>Í≤∞Í≥º</h2>
      <div class="results">
        <div><span class="k">f0 (Resonant Frequency)</span>: <span id="f0Out">-</span> Hz</div>
        <div><span class="k">XL (Inductive Reactance)</span>: <span id="xlOut">-</span> Œ©</div>
        <div><span class="k">XC (Capacitive Reactance)</span>: <span id="xcOut">-</span> Œ©</div>
        <div><span class="k">|Z| (Impedance Magnitude)</span>: <span id="zmagOut">-</span> Œ©</div>
        <div><span class="k">Q (Quality Factor)</span>: <span id="qOut">-</span></div>
        <div><span class="k">BW (Bandwidth)</span>: <span id="bwOut">-</span> Hz</div>
        <div><span class="k">Œ∂ (Damping Ratio)</span>: <span id="zetaOut">-</span></div>
      </div>
      <div id="qBadge" class="badge">Q badge</div>
      <p id="quickNote" class="hint"></p>
    </section>

    <section class="card" id="card-plot">
      <h2>|Z| vs f (log x-axis)</h2>
      <div class="buttons small">
        <button id="toggleZ" class="active">|Z|</button>
        <button id="toggleI" class="ghost">|I|</button>
      </div>
      <div class="buttons small">
        <button id="btnSavePNG">üñºÔ∏è Í∑∏ÎûòÌîÑ PNG Ï†ÄÏû•</button>
      </div>
      <div class="form-row" style="margin-top:6px">
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer">
          <input id="toggleBW" type="checkbox" checked />
          BW ÏùåÏòÅ ÌëúÏãú (f1‚Äìf2)
        </label>
      </div>
      <p id="bwNote" class="hint"></p>
      <canvas id="zChart" height="180"></canvas>
    </section>
  </main>

  <footer class="container foot">Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎßå ÎèôÏûë ¬∑ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏóÜÏùå</footer>

  <script>
window.Utils = (() => {
  'use strict';

  function trimZeros(str) {
    if (str.indexOf('.') === -1) return str;
    return str.replace(/\.?(0+)$/g, '');
  }

  function toSuperscript(n) {
    const map = { '0':'‚Å∞','1':'¬π','2':'¬≤','3':'¬≥','4':'‚Å¥','5':'‚Åµ','6':'‚Å∂','7':'‚Å∑','8':'‚Å∏','9':'‚Åπ','-':'‚Åª','+':'' };
    return String(n).split('').map(ch => map[ch] ?? ch).join('');
  }

  function fmt(x, d = 3) {
    if (!isFinite(x)) return '-';
    const ax = Math.abs(x);
    if (ax === 0) return '0';
    if (ax >= 1000 || (ax > 0 && ax < 0.01)) {
      const exp = Math.floor(Math.log10(ax));
      let mant = x / Math.pow(10, exp);
      const pow10 = Math.pow(10, d);
      mant = Math.round(mant * pow10) / pow10; // round to d digits
      if (Math.abs(mant) >= 10) { // handle 9.999 -> 10.000
        mant = mant / 10;
        return `${trimZeros(mant.toFixed(d))}√ó10<sup>${exp + 1}</sup>`;
      }
      return `${trimZeros(mant.toFixed(d))}√ó10<sup>${exp}</sup>`;
    }
    return trimZeros(Number(x).toFixed(d));
  }

  // Plain-text friendly formatter for tooltips (uses unicode superscripts)
  function fmtSup(x, d = 3) {
    if (!isFinite(x)) return '-';
    const ax = Math.abs(x);
    if (ax === 0) return '0';
    if (ax >= 1000 || (ax > 0 && ax < 0.01)) {
      const exp = Math.floor(Math.log10(ax));
      let mant = x / Math.pow(10, exp);
      const pow10 = Math.pow(10, d);
      mant = Math.round(mant * pow10) / pow10;
      if (Math.abs(mant) >= 10) {
        mant = mant / 10;
        return `${trimZeros(mant.toFixed(d))}√ó10${toSuperscript(exp + 1)}`;
      }
      return `${trimZeros(mant.toFixed(d))}√ó10${toSuperscript(exp)}`;
    }
    return trimZeros(Number(x).toFixed(d));
  }

  function parseAndValidate({ R, L, C, f, Vin }) {
    const vals = { R: +R, L: +L, C: +C, f: +f, Vin: +Vin };
    for (const [k, v] of Object.entries(vals)) {
      if (!isFinite(v) || isNaN(v)) throw new Error(`${k}: Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.`);
      if (v <= 0) throw new Error(`${k}: ÏñëÏùò Ïã§ÏàòÏó¨Ïïº Ìï©ÎãàÎã§.`);
    }
    // Í∂åÏû• Î≤îÏúÑ Í≤ÄÏÇ¨Îäî Ï†úÍ±∞: ÎπÑÌòÑÏã§Ï†Å Í∞íÎèÑ Í≥ÑÏÇ∞ ÌóàÏö©
    return vals;
  }

  function clampSweep({ fMin = 10, fMax = 100000 }) {
    if (!isFinite(fMin) || fMin <= 0) fMin = 1;
    if (!isFinite(fMax) || fMax <= fMin) fMax = fMin * 10;
    return { fMin, fMax };
  }

  return { fmt, fmtSup, parseAndValidate, clampSweep };
})();

window.MathCore = (() => {
  'use strict';

  function assertPositiveNumbers(...vals) {
    for (const v of vals) {
      if (!isFinite(v) || v <= 0) throw new Error('ÏûÖÎ†•Ïù¥ Ïú†Ìö®Ìïú ÏñëÏùò Ïã§ÏàòÍ∞Ä ÏïÑÎãôÎãàÎã§.');
    }
  }

  function calcCore(R, L, C, f) {
    assertPositiveNumbers(R, L, C, f);
    const w = 2 * Math.PI * f;
    const XL = w * L;
    const XC = 1 / (w * C);
    const Z = Math.hypot(R, XL - XC);
    const f0 = 1 / (2 * Math.PI * Math.sqrt(L * C));
    const Q = (1 / R) * Math.sqrt(L / C);
    const BW = f0 / Q;
    const zeta = 1 / (2 * Q);
    if (!isFinite(Z) || !isFinite(f0) || !isFinite(Q) || Q <= 0) throw new Error('Í≥ÑÏÇ∞ Ïã§Ìå®: ÎπÑÏ†ïÏÉÅ ÌååÎùºÎØ∏ÌÑ∞.');
    return { XL, XC, Z, f0, Q, BW, zeta };
  }

  function sweepMag(R, L, C, fMin, fMax, N = 400) {
    assertPositiveNumbers(R, L, C, fMin, fMax);
    if (fMax <= fMin) throw new Error('Ïä§Ïúï Î≤îÏúÑÍ∞Ä ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.');
    const f = new Array(N);
    const mag = new Array(N);
    const logMin = Math.log10(fMin);
    const logMax = Math.log10(fMax);
    for (let i = 0; i < N; i++) {
      const t = i / (N - 1);
      const fi = Math.pow(10, logMin + t * (logMax - logMin));
      const w = 2 * Math.PI * fi;
      const XL = w * L;
      const XC = 1 / (w * C);
      const Zi = Math.hypot(R, XL - XC);
      f[i] = fi;
      mag[i] = Zi;
    }
    return { f, mag };
  }

  function sweepI(R, L, C, fMin, fMax, N = 400, Vin = 1.0) {
    const { f, mag } = sweepMag(R, L, C, fMin, fMax, N);
    const cur = mag.map((z) => Vin / z);
    return { f, cur };
  }

  function computeBand(Q, f0) {
    assertPositiveNumbers(Q, f0);
    const w0 = 2 * Math.PI * f0;
    const term = Math.sqrt(1 + 1 / (4 * Q * Q));
    const w1 = w0 * (term - 1 / (2 * Q));
    const w2 = w0 * (term + 1 / (2 * Q));
    const f1 = w1 / (2 * Math.PI);
    const f2 = w2 / (2 * Math.PI);
    if (!isFinite(f1) || !isFinite(f2) || f1 <= 0 || f2 <= f1) throw new Error('ÎåÄÏó≠ Í≥ÑÏÇ∞ Ïã§Ìå®.');
    return { f1, f2 };
  }

  return { calcCore, sweepMag, sweepI, computeBand };
})();

window.Charts = (() => {
  'use strict';

  const { fmt, fmtSup } = window.Utils;

  const bwBandPlugin = {
    id: 'bwBandPlugin',
    beforeDraw(chart) {
      const bw = chart.$bw;
      if (!bw || bw.enabled === false || !isFinite(bw.f1) || !isFinite(bw.f2)) return;
      const { ctx, chartArea, scales } = chart;
      const x = scales.x;
      const f1x = x.getPixelForValue(bw.f1);
      const f2x = x.getPixelForValue(bw.f2);
      const left = Math.min(f1x, f2x);
      const right = Math.max(f1x, f2x);
      ctx.save();
      ctx.fillStyle = 'rgba(94,177,255,0.08)';
      ctx.fillRect(left, chartArea.top, right - left, chartArea.bottom - chartArea.top);
      ctx.strokeStyle = 'rgba(94,177,255,0.6)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(f1x, chartArea.top);
      ctx.lineTo(f1x, chartArea.bottom);
      ctx.moveTo(f2x, chartArea.top);
      ctx.lineTo(f2x, chartArea.bottom);
      ctx.stroke();
      ctx.restore();
    }
  };

  function initChart(canvasId, { logX = true, label = '|Z|(Œ©)' } = {}) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ label, data: [], borderColor: '#5eb1ff', backgroundColor: 'rgba(94,177,255,0.10)', borderWidth: 2, fill: true, pointRadius: 0, tension: 0.15 }] },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        interaction: { mode: 'nearest', intersect: false, axis: 'x' },
        elements: { point: { radius: 0, hitRadius: 8, hoverRadius: 0 } },
        scales: {
          x: {
            type: logX ? 'logarithmic' : 'linear',
            ticks: { color: '#9aa4b2' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          },
          y: {
            ticks: { color: '#9aa4b2' },
            grid: { color: 'rgba(255,255,255,0.05)' }
          }
        },
        plugins: {
          legend: { labels: { color: '#e7eaf0' } },
          tooltip: {
            callbacks: {
              title: (items) => items.length ? `f = ${fmtSup(items[0].parsed.x, 3)} Hz` : '',
              label: (item) => `${item.dataset.label}: ${fmtSup(item.parsed.y, 3)}`,
            }
          }
        },
        animation: false
      },
      plugins: [bwBandPlugin]
    });
    return chart;
  }

  function updateMagChart(chart, f, mag) {
    chart.data.labels = [];
    chart.data.datasets[0].label = '|Z|(Œ©)';
    chart.data.datasets[0].data = f.map((x, i) => ({ x, y: mag[i] }));
    chart.data.datasets[0].borderColor = '#5eb1ff';
    chart.data.datasets[0].backgroundColor = 'rgba(94,177,255,0.10)';
    chart.update();
  }

  function updateICurrentChart(chart, f, cur, Vin = 1.0) {
    chart.data.labels = [];
    chart.data.datasets[0].label = `|I|(A) @ Vin=${Vin}V`;
    chart.data.datasets[0].data = f.map((x, i) => ({ x, y: cur[i] }));
    chart.data.datasets[0].borderColor = '#5eb1ff';
    chart.data.datasets[0].backgroundColor = 'rgba(94,177,255,0.10)';
    chart.update();
  }

  function timestamp() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }

  function exportPNG(chart, { viewName = 'mag', scale = 2, background = '#ffffff', meta } = {}) {
    if (!chart || !chart.canvas) return;
    const src = chart.canvas;
    const w = src.width;
    const h = src.height;
    // temporarily switch to export colors (red theme)
    const ds = chart.data && chart.data.datasets && chart.data.datasets[0];
    const prevBorder = ds ? ds.borderColor : null;
    const prevBg = ds ? ds.backgroundColor : null;
    const prevLegendColor = chart.options?.plugins?.legend?.labels?.color || null;
    if (ds) {
      ds.borderColor = '#ff4d4d';
      ds.backgroundColor = 'rgba(255,77,77,0.12)';
      // Change legend label color to black
      if (chart.options?.plugins?.legend?.labels) {
        chart.options.plugins.legend.labels.color = '#000000';
      }
      chart.update(0);
    }
    const off = document.createElement('canvas');
    off.width = Math.max(1, Math.floor(w * scale));
    off.height = Math.max(1, Math.floor(h * scale));
    const ctx = off.getContext('2d');
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, off.width, off.height);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(src, 0, 0, off.width, off.height);

    // Axis annotations + meta panel
    try {
      const xIsLog = (chart.options && chart.options.scales && chart.options.scales.x && chart.options.scales.x.type === 'logarithmic');
      let yLabel = chart.data && chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].label ? chart.data.datasets[0].label : 'value';
      if (typeof yLabel === 'string') {
        if (yLabel.startsWith('|Z|')) yLabel = 'Impedance magnitude |Z| (Œ©)';
        else if (yLabel.startsWith('|I|')) {
          // Preserve actual Vin value from label (e.g., "|I|(A) @ Vin=2.5V")
          const vinMatch = yLabel.match(/Vin=([\d.]+)V/);
          const vinVal = vinMatch ? vinMatch[1] : '1';
          yLabel = `Current magnitude |I| (A) @ Vin=${vinVal}V`;
        }
      }
      const xLabel = `x: frequency f (Hz)` + (xIsLog ? ' [log]' : '');
      const pad = Math.round(12 * scale);
      ctx.fillStyle = '#000000';
      ctx.globalAlpha = 0.85;
      ctx.font = `${Math.round(12 * scale)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
      ctx.textBaseline = 'bottom';
      // Draw background strip for readability
      const text1 = xLabel;
      const text2 = `y: ${yLabel}`;
      const maxWidth = Math.max(ctx.measureText(text1).width, ctx.measureText(text2).width);
      const boxW = maxWidth + pad * 2;
      const boxH = Math.round(36 * scale);
      const boxX = pad;
      const boxY = off.height - pad - boxH;
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.globalAlpha = 1;
      // Draw x label
      ctx.fillStyle = '#000000';
      ctx.fillText(text1, boxX + pad, boxY + Math.round(16 * scale));
      // Draw y label with |Z| or |I| in black, rest in gray
      const yParts = yLabel.match(/^(.*?)(\|[ZI]\|)(.*)$/);
      if (yParts) {
        const [_, before, symbol, after] = yParts;
        let xPos = boxX + pad;
        if (before) {
          ctx.fillStyle = '#666666';
          ctx.fillText(`y: ${before}`, xPos, boxY + Math.round(32 * scale));
          xPos += ctx.measureText(`y: ${before}`).width;
        }
        ctx.fillStyle = '#000000';
        ctx.fillText(symbol, xPos, boxY + Math.round(32 * scale));
        xPos += ctx.measureText(symbol).width;
        if (after) {
          ctx.fillStyle = '#666666';
          ctx.fillText(after, xPos, boxY + Math.round(32 * scale));
        }
      } else {
        ctx.fillStyle = '#666666';
        ctx.fillText(text2, boxX + pad, boxY + Math.round(32 * scale));
      }

      if (meta) {
        const rightPad = pad;
        const lineH = Math.round(14 * scale);
        const lines = [
          `R = ${fmtSup(meta.R)} Œ©`,
          `L = ${fmtSup(meta.L)} H`,
          `C = ${fmtSup(meta.C)} F`,
          `f = ${fmtSup(meta.f)} Hz`,
          meta.Vin ? `Vin = ${fmtSup(meta.Vin)} V` : null,
        ].filter(Boolean);
        const widest = Math.max(...lines.map(t => ctx.measureText(t).width));
        const boxW2 = widest + rightPad * 2;
        const boxH2 = lineH * lines.length + rightPad;
        const boxX2 = off.width - boxW2 - rightPad;
        const boxY2 = rightPad;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fillRect(boxX2, boxY2, boxW2, boxH2);
        ctx.fillStyle = '#000000';
        ctx.textBaseline = 'top';
        lines.forEach((t, i) => {
          ctx.fillText(t, boxX2 + rightPad, boxY2 + i * lineH + Math.round(2 * scale));
        });
      }
    } catch (e) {
      // ignore annotation errors
    }
    const url = off.toDataURL('image/png');
    const name = `rlc_${viewName}_${timestamp()}.png`;
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    // Î™®Î∞îÏùº ÎåÄÏïà: ÏÉà ÌÉ≠ Ïó¥Í∏∞
    if (!/download/i.test(a.rel) && /Mobile|Android|iP(hone|ad)/.test(navigator.userAgent)) {
      window.open(url, '_blank');
    }
    // restore original colors
    if (ds) {
      ds.borderColor = prevBorder;
      ds.backgroundColor = prevBg;
      if (prevLegendColor !== null && chart.options?.plugins?.legend?.labels) {
        chart.options.plugins.legend.labels.color = prevLegendColor;
      }
      chart.update(0);
    }
  }

  return { initChart, updateMagChart, updateICurrentChart, exportPNG };
})();

window.UI = (() => {
  'use strict';

  const { fmt } = window.Utils;

  function renderResults(container, { f0, XL, XC, Z, Q, BW, zeta }) {
    document.getElementById('f0Out').innerHTML = fmt(f0);
    document.getElementById('xlOut').innerHTML = fmt(XL);
    document.getElementById('xcOut').innerHTML = fmt(XC);
    document.getElementById('zmagOut').innerHTML = fmt(Z);
    document.getElementById('qOut').innerHTML = fmt(Q);
    document.getElementById('bwOut').innerHTML = fmt(BW);
    document.getElementById('zetaOut').innerHTML = fmt(zeta);
  }

  function renderQBadge(container, Q) {
    const badge = document.getElementById('qBadge');
    const cls = ['badge'];
    let text = '';
    let title = '';
    let pros = [];
    let cons = [];
    if (Q < 0.5) {
      cls.push('overdamped');
      text = 'Í≥ºÎèÑ Í∞êÏá†(Overdamped)';
      title = 'Í≥µÏßÑÏù¥ Í±∞Ïùò ÎìúÎü¨ÎÇòÏßÄ ÏïäÏùå';
      pros = ['Í≥ºÎèÑ ÏùëÎãµÏù¥ Îπ†Î•¥Í≤å ÏàòÎ†¥', 'ÎßÅÏûâ(ÏûîÏßÑÎèô)Ïù¥ Ï†ÅÏùå'];
      cons = ['ÏÑ†ÌÉùÏÑ±Ïù¥ Îß§Ïö∞ ÎÇÆÏïÑ ÌïÑÌÑ∞ ÏÑ±Îä• Ï†ÄÌïò', 'Î∂ÑÌï¥Îä•Ïù¥ ÎÇÆÏïÑ ÌîºÌÅ¨ Íµ¨Î∂ÑÏù¥ Ïñ¥Î†§ÏõÄ'];
    } else if (Q < 2) {
      cls.push('broad');
      text = 'Í¥ëÎåÄÏó≠(Broad)';
      title = 'Í≥µÏßÑ Í≥°ÏÑ†Ïù¥ ÏôÑÎßå';
      pros = ['ÎÑìÏùÄ ÎåÄÏó≠ÏóêÏÑú ÎπÑÍµêÏ†Å ÏùºÏ†ïÌïú ÏùëÎãµ', 'ÏÑ§Í≥Ñ ÎØºÍ∞êÎèÑÍ∞Ä ÎÇÆÏïÑ ÏïàÏ†ïÏ†Å'];
      cons = ['Í≥µÏßÑ ÌîºÌÅ¨Í∞Ä ÏïΩÌï®', 'Î∂ÑÌï¥Îä•/ÏÑ†ÌÉùÏÑ±Ïù¥ ÎÇÆÏùå'];
    } else if (Q < 10) {
      cls.push('moderate');
      text = 'Î≥¥ÌÜµ(Moderate)';
      title = 'ÎπÑÍµêÏ†Å ÏÑ†Î™ÖÌïú Í≥µÏßÑ';
      pros = ['ÏÑ†ÌÉùÏÑ±Í≥º ÏïàÏ†ïÏÑ±Ïùò Í∑†Ìòï', 'Îã§ÏñëÌïú ÏùºÎ∞ò Ïö©ÎèÑÏóê Ï†ÅÌï©'];
      cons = ['Í≥†Î∂ÑÌï¥Îä• ÌïÑÌÑ∞/Ï†ïÎ∞Ä ÏÑºÏã±ÏóêÎäî Î∂ÄÏ°±Ìï† Ïàò ÏûàÏùå'];
    } else {
      cls.push('sharp');
      text = 'ÏòàÎ¶¨Ìï®(Sharp)';
      title = 'Îß§Ïö∞ ÎÇ†Ïπ¥Î°úÏö¥ Í≥µÏßÑ';
      pros = ['Îß§Ïö∞ ÎÜíÏùÄ ÏÑ†ÌÉùÏÑ±Í≥º Î∂ÑÌï¥Îä•', 'Ï†ïÎ∞Ä Ï∏°Ï†ï/ÌïÑÌÑ∞ÎßÅÏóê Ïú†Î¶¨'];
      cons = ['ÎßÅÏûâÏù¥ Í∏∏Ïñ¥ Í≥ºÎèÑ ÏùëÎãµÏù¥ Í∏∏Ïñ¥Ïßê', 'Î∂ÄÌíà Í≥µÏ∞®/ÏÜêÏã§ Î≥ÄÌôîÏóê ÎØºÍ∞ê'];
    }
    badge.className = cls.join(' ');
    badge.textContent = text;
    const note = document.getElementById('quickNote');
    if (note) {
      const qv = Utils.fmt(Q);
      const prosLis = pros.map((t) => `<li>${t}</li>`).join('');
      const consLis = cons.map((t) => `<li>${t}</li>`).join('');
      note.innerHTML = `
        <div class="qnote">
          <div class="qtitle">Q=${qv} ¬∑ ${title}</div>
          <div class="qcols">
            <div>
              <div class="qsub">Ïû•Ï†ê</div>
              <ul>${prosLis}</ul>
            </div>
            <div>
              <div class="qsub">Îã®Ï†ê</div>
              <ul>${consLis}</ul>
            </div>
          </div>
        </div>`;
    }
  }

  return { renderResults, renderQBadge };
})();

window.App = (() => {
  'use strict';

  const { fmt, parseAndValidate } = window.Utils;
  const { calcCore, sweepMag, sweepI, computeBand } = window.MathCore;
  const { initChart, updateMagChart, updateICurrentChart, exportPNG } = window.Charts;
  const { renderResults, renderQBadge } = window.UI;

  const el = (id) => document.getElementById(id);

  let chart;
  let mode = 'Z'; // 'Z' or 'I'
  let bwEnabled = true;
  let lastRes = null; // remember last calc results {Q, f0}

  function readInputs() {
    return {
      R: el('rInput').value,
      L: el('lInput').value,
      C: el('cInput').value,
      f: el('fInput').value,
      Vin: el('vinInput').value,
    };
  }

  function setDefaults() {
    el('rInput').value = '100';
    el('lInput').value = '0.01';
    el('cInput').value = '0.000001';
    el('fInput').value = '1000';
    el('vinInput').value = '1.0';
  }

  function recalcAndRender() {
    try {
      const vals = parseAndValidate(readInputs());
      const res = calcCore(vals.R, vals.L, vals.C, vals.f);
      renderResults(null, res);
      renderQBadge(null, res.Q);
      el('inlineError').textContent = '';
      lastRes = { Q: res.Q, f0: res.f0 };

      // Sweep range around f0 (narrowed)
      const fMin = Math.max(1, res.f0 / 20);
      const fMax = res.f0 * 20;
      if (mode === 'Z') {
        const { f, mag } = sweepMag(vals.R, vals.L, vals.C, fMin, fMax, 400);
        updateMagChart(chart, f, mag);
      } else {
        const { f, cur } = sweepI(vals.R, vals.L, vals.C, fMin, fMax, 400, vals.Vin);
        updateICurrentChart(chart, f, cur, vals.Vin);
      }

      // Band markers
      const { f1, f2 } = computeBand(res.Q, res.f0);
      chart.$bw = { f1, f2, enabled: bwEnabled };
      chart.update();

      // Update BW note (only if enabled)
      const note = el('bwNote');
      if (note) {
        if (bwEnabled) {
          note.innerHTML = `ÎåÄÏó≠Ìè≠ ÏòÅÏó≠: f1=${fmt(f1)} Hz ~ f2=${fmt(f2)} Hz (Q, f0 Í∏∞Î∞ò)`;
        } else {
          note.textContent = '';
        }
      }
    } catch (e) {
      el('inlineError').textContent = e.message || 'ÏûÖÎ†•Ïù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.';
    }
  }

  function wireEvents() {
    el('btnCalc').addEventListener('click', recalcAndRender);
    el('btnReset').addEventListener('click', () => { setDefaults(); recalcAndRender(); });
    ['rInput','lInput','cInput','fInput','vinInput'].forEach((id) => {
      el(id).addEventListener('input', () => { el('inlineError').textContent = ''; });
    });
    el('toggleZ').addEventListener('click', () => {
      mode = 'Z';
      el('toggleZ').classList.add('active');
      el('toggleZ').classList.remove('ghost');
      el('toggleI').classList.remove('active');
      el('toggleI').classList.add('ghost');
      recalcAndRender();
    });
    el('toggleI').addEventListener('click', () => {
      mode = 'I';
      el('toggleI').classList.add('active');
      el('toggleI').classList.remove('ghost');
      el('toggleZ').classList.remove('active');
      el('toggleZ').classList.add('ghost');
      recalcAndRender();
    });
    const bwChk = el('toggleBW');
    if (bwChk) {
      bwChk.addEventListener('change', (e) => {
        bwEnabled = !!e.target.checked;
        if (!chart) return;
        if (!bwEnabled) {
          // disable and force redraw, clear note
          chart.$bw = { enabled: false };
          chart.update();
          const note = el('bwNote');
          if (note) note.textContent = '';
          return;
        }
        // enable: recompute from last results if available
        try {
          if (lastRes && lastRes.Q && lastRes.f0) {
            const { f1, f2 } = computeBand(lastRes.Q, lastRes.f0);
            chart.$bw = { f1, f2, enabled: true };
            chart.update();
            const note = el('bwNote');
            if (note) note.innerHTML = `ÎåÄÏó≠Ìè≠ ÏòÅÏó≠: f1=${fmt(f1)} Hz ~ f2=${fmt(f2)} Hz (Q, f0 Í∏∞Î∞ò)`;
          }
        } catch {}
      });
    }
    const saveBtn = el('btnSavePNG');
    if (saveBtn) {
      saveBtn.addEventListener('click', () => {
        const viewName = mode === 'Z' ? 'mag' : 'i';
        try {
          const vals = parseAndValidate(readInputs());
          exportPNG(chart, { viewName, scale: 2, background: '#ffffff', meta: { R: vals.R, L: vals.L, C: vals.C, f: vals.f, Vin: vals.Vin } });
        } catch (e) {
          el('inlineError').textContent = e.message || 'ÏûÖÎ†•Ïù¥ ÏûòÎ™ªÎêòÏóàÏäµÎãàÎã§.';
        }
      });
    }
  }

  function init() {
    chart = initChart('zChart', { logX: true, label: '|Z|(Œ©)' });
    setDefaults();
    wireEvents();
    // normalize toggle visual state
    el('toggleZ').classList.add('active');
    el('toggleZ').classList.remove('ghost');
    el('toggleI').classList.remove('active');
    el('toggleI').classList.add('ghost');
    recalcAndRender();
  }

  return { init };
})();

window.addEventListener('DOMContentLoaded', () => {
  window.App.init();
});
  </script>
</body>
</html>

